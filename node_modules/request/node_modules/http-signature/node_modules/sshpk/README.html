<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8">
    <title>Vitor Leal</title>
    <meta name="description" content="Consultor de Sistemas e Negócios no Centro de Inovação da Telefonica Vivo trabalhando com Internet of Things e Smart Cities.">

    <meta name="theme-color"           content="#48CBAB">

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport"              content="width=device-width, initial-scale=1">

    <meta property="og:url"            content="https://vitorleal.com/">
    <meta property="og:image"          content="https://vitorleal.com//assets/img/vitorleal.jpg">
    <meta property="og:title"          content="Vitor Leal">
    <meta property="og:description"    content="Consultor de Sistemas e Negócios no Centro de Inovação da Telefonica Vivo trabalhando com Internet of Things e Smart Cities.">
    <meta property="og:type"           content="blog">

    <meta name="twitter:card"          content="summary">
    <meta name="twitter:creator"       content="@vitorleal">
    <meta name="twitter:site"          content="@vitorleal">
    <meta name="twitter:domain"        content="https://vitorleal.com/">
    <meta name="twitter:title"         content="Vitor Leal">
    <meta name="twitter:description"   content="Consultor de Sistemas e Negócios no Centro de Inovação da Telefonica Vivo trabalhando com Internet of Things e Smart Cities.">
    <meta property="og:image"          content="https://vitorleal.com//assets/img/vitorleal.jpg">

    <link href="./assets/img/favicon.png"    rel="icon">
    <link href="./assets/img/favicon.big.png" rel="icon" sizes="192x192">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:regular,bold,italic,thin,light,bolditalic,black,medium&amp;lang=en">
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="./assets/css/prism.css">
    <link rel="stylesheet" href="./assets/css/material.min.css">
    <link rel="stylesheet" href="./assets/css/main.css">

    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-5427757-17', 'auto');
  ga('send', 'pageview');
</script>

  </head>

  <body>
    <section class="mdl-layout mdl-js-layout mdl-layout--fixed-header">
      <div class="android-header mdl-layout__header mdl-layout__header--waterfall">
  <div class="mdl-layout__header-row">
    <h1 class="android-font android-title mdl-layout-title mdl-typography--text-uppercase android-link">Vitor Leal</h1>

    <div class="android-header-spacer mdl-layout-spacer"></div>

    <div class="android-navigation-container">
      <nav class="android-navigation mdl-navigation">
        
        <a class="mdl-navigation__link mdl-typography--text-uppercase
          "
          href="https://vitorleal.com/">
          Home
        </a>
        
        <a class="mdl-navigation__link mdl-typography--text-uppercase
          active"
          href="https://vitorleal.com/blog">
          Blog
        </a>
        
        <a class="mdl-navigation__link mdl-typography--text-uppercase
          "
          href="https://vitorleal.com/projetos">
          Projetos
        </a>
        
        <a class="mdl-navigation__link mdl-typography--text-uppercase
          "
          href="https://vitorleal.com/portfolio">
          Portfolio
        </a>
        
        <a class="mdl-navigation__link mdl-typography--text-uppercase
          "
          href="https://vitorleal.com/talks">
          Talks
        </a>
        
      </nav>
    </div>
  </div>
</div>

<div class="android-drawer mdl-layout__drawer">
  <nav class="mdl-navigation">
    
    <a class="mdl-navigation__link" href="https://vitorleal.com/">
      Home
    </a>
    
    <a class="mdl-navigation__link" href="https://vitorleal.com/blog">
      Blog
    </a>
    
    <a class="mdl-navigation__link" href="https://vitorleal.com/projetos">
      Projetos
    </a>
    
    <a class="mdl-navigation__link" href="https://vitorleal.com/portfolio">
      Portfolio
    </a>
    
    <a class="mdl-navigation__link" href="https://vitorleal.com/talks">
      Talks
    </a>
    
    
    <a class="mdl-navigation__link" href="https://github.com/vitorleal" target="_blank">
      GitHub
    </a>
    
    <a class="mdl-navigation__link" href="http://www.linkedin.com/in/vitorleal" target="_blank">
      LinkedIn
    </a>
    
    <a class="mdl-navigation__link" href="https://twitter.com/@vitorleal" target="_blank">
      Twitter
    </a>
    
  </nav>
</div>


      <div class="android-content mdl-layout__content">
        
            <h1>sshpk</h1><p>Parse, convert, fingerprint and use SSH keys (both public and private) in pure
node -- no <code>ssh-keygen</code> or other external dependencies.</p>
<p>Supports RSA, DSA, ECDSA (nistp-*) and ED25519 key types, in PEM (PKCS#1, 
PKCS#8) and OpenSSH formats.</p>
<p>This library has been extracted from
<a href="https://github.com/joyent/node-http-signature"><code>node-http-signature</code></a>
(work by <a href="https://github.com/mcavage">Mark Cavage</a> and
<a href="https://github.com/bahamas10">Dave Eddy</a>) and
<a href="https://github.com/bahamas10/node-ssh-fingerprint"><code>node-ssh-fingerprint</code></a>
(work by Dave Eddy), with additions (including ECDSA support) by
<a href="https://github.com/arekinath">Alex Wilson</a>.</p>
<h2>Install</h2><pre><code>npm install sshpk
</code></pre><h2>Examples</h2><pre><code class="language-js">var sshpk = require(&#39;sshpk&#39;);

var fs = require(&#39;fs&#39;);

/* Read in an OpenSSH-format public key */
var keyPub = fs.readFileSync(&#39;id_rsa.pub&#39;);
var key = sshpk.parseKey(keyPub, &#39;ssh&#39;);

/* Get metadata about the key */
console.log(&#39;type =&gt; %s&#39;, key.type);
console.log(&#39;size =&gt; %d bits&#39;, key.size);
console.log(&#39;comment =&gt; %s&#39;, key.comment);

/* Compute key fingerprints, in new OpenSSH (&gt;6.7) format, and old MD5 */
console.log(&#39;fingerprint =&gt; %s&#39;, key.fingerprint().toString());
console.log(&#39;old-style fingerprint =&gt; %s&#39;, key.fingerprint(&#39;md5&#39;).toString());
</code></pre>
<p>Example output:</p>
<pre><code>type =&gt; rsa
size =&gt; 2048 bits
comment =&gt; foo@foo.com
fingerprint =&gt; SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w
old-style fingerprint =&gt; a0:c8:ad:6c:32:9a:32:fa:59:cc:a9:8c:0a:0d:6e:bd
</code></pre><p>More examples: converting between formats:</p>
<pre><code class="language-js">/* Read in a PEM public key */
var keyPem = fs.readFileSync(&#39;id_rsa.pem&#39;);
var key = sshpk.parseKey(keyPem, &#39;pem&#39;);

/* Convert to PEM PKCS#8 public key format */
var pemBuf = key.toBuffer(&#39;pkcs8&#39;);

/* Convert to SSH public key format (and return as a string) */
var sshKey = key.toString(&#39;ssh&#39;);
</code></pre>
<p>Signing and verifying:</p>
<pre><code class="language-js">/* Read in an OpenSSH/PEM *private* key */
var keyPriv = fs.readFileSync(&#39;id_ecdsa&#39;);
var key = sshpk.parsePrivateKey(keyPriv, &#39;pem&#39;);

var data = &#39;some data&#39;;

/* Sign some data with the key */
var s = key.createSign(&#39;sha1&#39;);
s.update(data);
var signature = s.sign();

/* Now load the public key (could also use just key.toPublic()) */
var keyPub = fs.readFileSync(&#39;id_ecdsa.pub&#39;);
key = sshpk.parseKey(keyPub, &#39;ssh&#39;);

/* Make a crypto.Verifier with this key */
var v = key.createVerify(&#39;sha1&#39;);
v.update(data);
var valid = v.verify(signature);
/* =&gt; true! */
</code></pre>
<p>Matching fingerprints with keys:</p>
<pre><code class="language-js">var fp = sshpk.parseFingerprint(&#39;SHA256:PYC9kPVC6J873CSIbfp0LwYeczP/W4ffObNCuDJ1u5w&#39;);

var keys = [sshpk.parseKey(...), sshpk.parseKey(...), ...];

keys.forEach(function (key) {
    if (fp.matches(key))
        console.log(&#39;found it!&#39;);
});
</code></pre>
<h2>Usage</h2><h2>Public keys</h2><h3><code>parseKey(data[, format = &#39;auto&#39;[, options]])</code></h3><p>Parses a key from a given data format and returns a new <code>Key</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>data</code> -- Either a Buffer or String, containing the key</li>
<li><code>format</code> -- String name of format to use, valid options are:<ul>
<li><code>auto</code>: choose automatically from all below</li>
<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code>ssh</code>: standard OpenSSH format,</li>
<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>
<li><code>rfc4253</code>: raw OpenSSH wire format</li>
<li><code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by <pre><code>       `ssh-keygen -o`
</code></pre></li>
</ul>
</li>
<li><code>options</code> -- Optional Object, extra options, with keys:<ul>
<li><code>filename</code> -- Optional String, name for the key being parsed <pre><code>          (eg. the filename that was opened). Used to generate
          Error messages
</code></pre></li>
<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an<pre><code>            encrypted PEM file
</code></pre></li>
</ul>
</li>
</ul>
<h3><code>Key.isKey(obj)</code></h3><p>Returns <code>true</code> if the given object is a valid <code>Key</code> object created by a version
of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<h3><code>Key#type</code></h3><p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>
<h3><code>Key#size</code></h3><p>Integer, &quot;size&quot; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>
<h3><code>Key#comment</code></h3><p>Optional string, a key comment used by some formats (eg the <code>ssh</code> format).</p>
<h3><code>Key#curve</code></h3><p>Only present if <code>this.type === &#39;ecdsa&#39;</code>, string containing the name of the
named curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>
and <code>nistp521</code>.</p>
<h3><code>Key#toBuffer([format = &#39;ssh&#39;])</code></h3><p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- String name of format to use, for valid options see <code>parseKey()</code></li>
</ul>
<h3><code>Key#toString([format = &#39;ssh])</code></h3><p>Same as <code>this.toBuffer(format).toString()</code>.</p>
<h3><code>Key#fingerprint([algorithm = &#39;sha256&#39;])</code></h3><p>Creates a new <code>Fingerprint</code> object representing this Key&#39;s fingerprint.</p>
<p>Parameters</p>
<ul>
<li><code>algorithm</code> -- String name of hash algorithm to use, valid options are <code>md5</code>,<pre><code>           `sha1`, `sha256`, `sha384`, `sha512`
</code></pre></li>
</ul>
<h3><code>Key#createVerify([hashAlgorithm])</code></h3><p>Creates a <code>crypto.Verifier</code> specialized to use this Key (and the correct public
key algorithm to match it). The returned Verifier has the same API as a regular
one, except that the <code>verify()</code> function takes only the target signature as an
argument.</p>
<p>Parameters</p>
<ul>
<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any<pre><code>               supported by OpenSSL are valid, usually including
               `sha1`, `sha256`.
</code></pre></li>
</ul>
<p><code>v.verify(signature[, format])</code> Parameters</p>
<ul>
<li><code>signature</code> -- either a Signature object, or a Buffer or String</li>
<li><code>format</code> -- optional String, name of format to interpret given String with.<pre><code>        Not valid if `signature` is a Signature or Buffer.
</code></pre></li>
</ul>
<h3><code>Key#createDiffieHellman()</code></h3><h3><code>Key#createDH()</code></h3><p>Creates a Diffie-Hellman key exchange object initialized with this key and all
necessary parameters. This has the same API as a <code>crypto.DiffieHellman</code>
instance, except that functions take <code>Key</code> and <code>PrivateKey</code> objects as
arguments, and return them where indicated for.</p>
<p>This is only valid for keys belonging to a cryptosystem that supports DHE
or a close analogue (i.e. <code>dsa</code>, <code>ecdsa</code> and <code>curve25519</code> keys). An attempt
to call this function on other keys will yield an <code>Error</code>.</p>
<h2>Private keys</h2><h3><code>parsePrivateKey(data[, format = &#39;auto&#39;[, options]])</code></h3><p>Parses a private key from a given data format and returns a new
<code>PrivateKey</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>data</code> -- Either a Buffer or String, containing the key</li>
<li><code>format</code> -- String name of format to use, valid options are:<ul>
<li><code>auto</code>: choose automatically from all below</li>
<li><code>pem</code>: supports both PKCS#1 and PKCS#8</li>
<li><code>ssh</code>, <code>openssh</code>: new post-OpenSSH 6.5 internal format, produced by <pre><code>              `ssh-keygen -o`
</code></pre></li>
<li><code>pkcs1</code>, <code>pkcs8</code>: variants of <code>pem</code></li>
<li><code>rfc4253</code>: raw OpenSSH wire format</li>
</ul>
</li>
<li><code>options</code> -- Optional Object, extra options, with keys:<ul>
<li><code>filename</code> -- Optional String, name for the key being parsed <pre><code>          (eg. the filename that was opened). Used to generate
          Error messages
</code></pre></li>
<li><code>passphrase</code> -- Optional String, encryption passphrase used to decrypt an<pre><code>            encrypted PEM file
</code></pre></li>
</ul>
</li>
</ul>
<h3><code>PrivateKey.isPrivateKey(obj)</code></h3><p>Returns <code>true</code> if the given object is a valid <code>PrivateKey</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<h3><code>PrivateKey#type</code></h3><p>String, the type of key. Valid options are <code>rsa</code>, <code>dsa</code>, <code>ecdsa</code>.</p>
<h3><code>PrivateKey#size</code></h3><p>Integer, &quot;size&quot; of the key in bits. For RSA/DSA this is the size of the modulus;
for ECDSA this is the bit size of the curve in use.</p>
<h3><code>PrivateKey#curve</code></h3><p>Only present if <code>this.type === &#39;ecdsa&#39;</code>, string containing the name of the
named curve used with this key. Possible values include <code>nistp256</code>, <code>nistp384</code>
and <code>nistp521</code>.</p>
<h3><code>PrivateKey#toBuffer([format = &#39;pkcs1&#39;])</code></h3><p>Convert the key into a given data format and return the serialized key as
a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- String name of format to use, valid options are listed under <pre><code>        `parsePrivateKey`. Note that ED25519 keys default to `openssh`
        format instead (as they have no `pkcs1` representation).
</code></pre></li>
</ul>
<h3><code>PrivateKey#toString([format = &#39;pkcs1&#39;])</code></h3><p>Same as <code>this.toBuffer(format).toString()</code>.</p>
<h3><code>PrivateKey#toPublic()</code></h3><p>Extract just the public part of this private key, and return it as a <code>Key</code>
object.</p>
<h3><code>PrivateKey#fingerprint([algorithm = &#39;sha256&#39;])</code></h3><p>Same as <code>this.toPublic().fingerprint()</code>.</p>
<h3><code>PrivateKey#createVerify([hashAlgorithm])</code></h3><p>Same as <code>this.toPublic().createVerify()</code>.</p>
<h3><code>PrivateKey#createSign([hashAlgorithm])</code></h3><p>Creates a <code>crypto.Sign</code> specialized to use this PrivateKey (and the correct
key algorithm to match it). The returned Signer has the same API as a regular
one, except that the <code>sign()</code> function takes no arguments, and returns a
<code>Signature</code> object.</p>
<p>Parameters</p>
<ul>
<li><code>hashAlgorithm</code> -- optional String name of hash algorithm to use, any<pre><code>               supported by OpenSSL are valid, usually including
               `sha1`, `sha256`.
</code></pre></li>
</ul>
<p><code>v.sign()</code> Parameters</p>
<ul>
<li>none</li>
</ul>
<h3><code>PrivateKey#derive(newType)</code></h3><p>Derives a related key of type <code>newType</code> from this key. Currently this is
only supported to change between <code>ed25519</code> and <code>curve25519</code> keys which are
stored with the same private key (but usually distinct public keys in order
to avoid degenerate keys that lead to a weak Diffie-Hellman exchange).</p>
<p>Parameters</p>
<ul>
<li><code>newType</code> -- String, type of key to derive, either <code>ed25519</code> or <code>curve25519</code></li>
</ul>
<h2>Fingerprints</h2><h3><code>parseFingerprint(fingerprint[, algorithms])</code></h3><p>Pre-parses a fingerprint, creating a <code>Fingerprint</code> object that can be used to
quickly locate a key by using the <code>Fingerprint#matches</code> function.</p>
<p>Parameters</p>
<ul>
<li><code>fingerprint</code> -- String, the fingerprint value, in any supported format</li>
<li><code>algorithms</code> -- Optional list of strings, names of hash algorithms to limit<pre><code>            support to. If `fingerprint` uses a hash algorithm not on
            this list, throws `InvalidAlgorithmError`.
</code></pre></li>
</ul>
<h3><code>Fingerprint.isFingerprint(obj)</code></h3><p>Returns <code>true</code> if the given object is a valid <code>Fingerprint</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<h3><code>Fingerprint#toString([format])</code></h3><p>Returns a fingerprint as a string, in the given format.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- Optional String, format to use, valid options are <code>hex</code> and<pre><code>        `base64`. If this `Fingerprint` uses the `md5` algorithm, the
        default format is `hex`. Otherwise, the default is `base64`.
</code></pre></li>
</ul>
<h3><code>Fingerprint#matches(key)</code></h3><p>Verifies whether or not this <code>Fingerprint</code> matches a given <code>Key</code>. This function
uses double-hashing to avoid leaking timing information. Returns a boolean.</p>
<p>Parameters</p>
<ul>
<li><code>key</code> -- a <code>Key</code> object, the key to match this fingerprint against</li>
</ul>
<h2>Signatures</h2><h3><code>parseSignature(signature, algorithm, format)</code></h3><p>Parses a signature in a given format, creating a <code>Signature</code> object. Useful
for converting between the SSH and ASN.1 (PKCS/OpenSSL) signature formats, and
also returned as output from <code>PrivateKey#createSign().sign()</code>.</p>
<p>A Signature object can also be passed to a verifier produced by
<code>Key#createVerify()</code> and it will automatically be converted internally into the
correct format for verification.</p>
<p>Parameters</p>
<ul>
<li><code>signature</code> -- a Buffer (binary) or String (base64), data of the actual<pre><code>           signature in the given format
</code></pre></li>
<li><code>algorithm</code> -- a String, name of the algorithm to be used, possible values<pre><code>           are `rsa`, `dsa`, `ecdsa`
</code></pre></li>
<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>
</ul>
<h3><code>Signature.isSignature(obj)</code></h3><p>Returns <code>true</code> if the given object is a valid <code>Signature</code> object created by a
version of <code>sshpk</code> compatible with this one.</p>
<p>Parameters</p>
<ul>
<li><code>obj</code> -- Object to identify</li>
</ul>
<h3><code>Signature#toBuffer([format = &#39;asn1&#39;])</code></h3><p>Converts a Signature to the given format and returns it as a Buffer.</p>
<p>Parameters</p>
<ul>
<li><code>format</code> -- a String, either <code>asn1</code> or <code>ssh</code></li>
</ul>
<h3><code>Signature#toString([format = &#39;asn1&#39;])</code></h3><p>Same as <code>this.toBuffer(format).toString(&#39;base64&#39;)</code>.</p>
<h2>Errors</h2><h3><code>InvalidAlgorithmError</code></h3><p>The specified algorithm is not valid, either because it is not supported, or
because it was not included on a list of allowed algorithms.</p>
<p>Thrown by <code>Fingerprint.parse</code>, <code>Key#fingerprint</code>.</p>
<p>Properties</p>
<ul>
<li><code>algorithm</code> -- the algorithm that could not be validated</li>
</ul>
<h3><code>FingerprintFormatError</code></h3><p>The fingerprint string given could not be parsed as a supported fingerprint
format, or the specified fingerprint format is invalid.</p>
<p>Thrown by <code>Fingerprint.parse</code>, <code>Fingerprint#toString</code>.</p>
<p>Properties</p>
<ul>
<li><code>fingerprint</code> -- if caused by a fingerprint, the string value given</li>
<li><code>format</code> -- if caused by an invalid format specification, the string value given</li>
</ul>
<h3><code>KeyParseError</code></h3><p>The key data given could not be parsed as a valid key.</p>
<p>Properties</p>
<ul>
<li><code>keyName</code> -- <code>filename</code> that was given to <code>Key#parse</code></li>
<li><code>format</code> -- the <code>format</code> that was trying to parse the key</li>
<li><code>innerErr</code> -- the inner Error thrown by the format parser</li>
</ul>
<h3><code>KeyEncryptedError</code></h3><p>The key is encrypted with a symmetric key (ie, it is password protected). The
parsing operation would succeed if it was given the <code>passphrase</code> option.</p>
<p>Properties</p>
<ul>
<li><code>keyName</code> -- <code>filename</code> that was given to <code>Key#parse</code></li>
<li><code>format</code> -- the <code>format</code> that was trying to parse the key (currently can only<pre><code>        be `&quot;pem&quot;`)
</code></pre></li>
</ul>
<h2>Friends of sshpk</h2><ul>
<li><a href="https://github.com/arekinath/node-sshpk-agent"><code>sshpk-agent</code></a> is a library
for speaking the <code>ssh-agent</code> protocol from node.js, which uses <code>sshpk</code></li>
</ul>
        

        <footer class="android-footer mdl-mega-footer">
  <div class="mdl-mega-footer--top-section">
    <div class="mdl-mega-footer--left-section">
    </div>

    <div class="mdl-mega-footer--right-section">
      <a class="mdl-typography--font-light" href="#top">
        Ir para o topo <i class="material-icons">expand_less</i>
      </a>
    </div>
  </div>

  <div class="mdl-mega-footer--middle-section">
    <p class="mdl-typography--font-light">
      Copyright &copy; 2016 - Vitor Leal - <a href="mailto:me@vitorleal.com">me@vitorleal.com</a>
    </p>
  </div>

  <div class="mdl-mega-footer--bottom-section">
    
    <a class="android-link mdl-typography--font-light"
      href="https://vitorleal.com/">
      Home
    </a>
    
    <a class="android-link mdl-typography--font-light"
      href="https://vitorleal.com/blog">
      Blog
    </a>
    
    <a class="android-link mdl-typography--font-light"
      href="https://vitorleal.com/projetos">
      Projetos
    </a>
    
    <a class="android-link mdl-typography--font-light"
      href="https://vitorleal.com/portfolio">
      Portfolio
    </a>
    
    <a class="android-link mdl-typography--font-light"
      href="https://vitorleal.com/talks">
      Talks
    </a>
    
    
    <a class="android-link mdl-typography--font-light" href="https://github.com/vitorleal" target="_blank">
      GitHub
    </a>
    
    <a class="android-link mdl-typography--font-light" href="http://www.linkedin.com/in/vitorleal" target="_blank">
      LinkedIn
    </a>
    
    <a class="android-link mdl-typography--font-light" href="https://twitter.com/@vitorleal" target="_blank">
      Twitter
    </a>
    
  </div>
</footer>

      </div>
    </section>

    <script src="./assets/js/material.min.js" ></script>
    <script src="./assets/js/prism.js"></script>
  </body>
</html>
